#
# Copyright (c) FIRST and other WPILib contributors.
# Open Source Software; you can modify and/or share it under the terms of
# the WPILib BSD license file in the root directory of this project.
#

#
# See the notes for the other physics sample
#

import wpilib.simulation
import wpilib.simulation as simlib

from pyfrc.physics.core import PhysicsInterface
from pyfrc.physics import motor_cfgs, tankmodel
from pyfrc.physics.drivetrains import four_motor_swerve_drivetrain
from pyfrc.physics.units import units
import wpimath.geometry as geo
import rev


import typing

import constants
if typing.TYPE_CHECKING:
    from robot import MyRobot
    from robotcontainer import RobotContainer


class PhysicsEngine:
    """
    Simulates a 4-wheel robot using Tank Drive joystick control
    """

    def __init__(self, physics_controller: PhysicsInterface, robot: "MyRobot"):
        """
        :param physics_controller: `pyfrc.physics.core.Physics` object
                                   to communicate simulation effects to
        :param robot: your robot object
        """

        self.physics_controller = physics_controller
        #self.field = wpilib.Field2d()


        devices = wpilib.simulation.SimDeviceSim.enumerateDevices()
        print(f'Devices are: {devices}')

        # NavX (SPI interface) - no idea why the "4" is there, seems to be the default name generated by the navx code
        self.navx = simlib.SimDeviceSim("navX-Sensor[4]")
        self.navx_yaw = self.navx.getDouble("Yaw")

        # set up a fake swerve drive with PWMs
        self.spark_dict = {}
        # self.spark_ids = [21, 23, 25, 27, 20, 22, 24, 26]
        self.spark_ids = [23, 27, 21, 25, 22, 26, 20, 24]
        self.spark_drives = ['lr_motor_spark', 'rr_motor_spark', 'lf_motor_spark', 'rf_motor_spark']
        self.spark_turns = ['lr_angle_spark', 'rr_angle_spark', 'lf_angle_spark', 'rf_angle_spark']
        self.spark_names = self.spark_drives + self.spark_turns
        for idx, (spark_name, can_id) in enumerate(zip(self.spark_names, self.spark_ids)):
            spark = simlib.SimDeviceSim(f'SPARK MAX [{can_id}]')
            position = spark.getDouble('Position').value
            velocity = spark.getDouble('Velocity').value
            output = spark.getDouble('Applied Output').value
            self.spark_dict.update({spark_name: {'controller': spark, 'position': position,
                                                 'velocity': velocity, 'output': output}})

        for key, value in self.spark_dict.items():  # see if these make sense
            print(f'{key}: {value}')

        # set up the initial location of the robot on the field
        self.x, self.y = constants.k_start_x, constants.k_start_y
        initial_pose = geo.Pose2d(0, 0, geo.Rotation2d())
        self.physics_controller.move_robot(geo.Transform2d(self.x, self.y, 0))

        # Motors

        # Change these parameters to fit your robot!
        bumper_width = 3.25 * units.inch

    def update_sim(self, now: float, tm_diff: float) -> None:
        """
        Called when the simulation parameters for the program need to be
        updated.

        :param now: The current time as a float
        :param tm_diff: The amount of time that has passed since the last
                        time that this function was called
        """

        # Simulate the drivetrain (only front motors used because read should be in sync)
        ##lf_motor = self.lf_motor.getSpeed()
        ##rf_motor = self.rf_motor.getSpeed()

        ##transform = self.drivetrain.calculate(lf_motor, rf_motor, tm_diff)
        ##pose = self.physics_controller.move_robot(transform)

        # Update the gyro simulation
        # -> FRC gyros are positive clockwise, but the returned pose is positive
        #    counter-clockwise
        ##self.gyro.setAngle(-pose.rotation().degrees())

        # send the speeds from the spark sim devices to the fourmotorswervedrivetrain
        for idx, (spark_name, can_id) in enumerate(zip(self.spark_names, self.spark_ids)):
            spark = simlib.SimDeviceSim(f'SPARK MAX [{can_id}]')
            position = spark.getDouble('Position').value
            velocity = spark.getDouble('Velocity').value
            output = spark.getDouble('Applied Output').value
            self.spark_dict.update({spark_name: {'controller': spark, 'position': position,
                                                 'velocity': velocity, 'output': output}})
        velocities = [self.spark_dict[spark]['velocity'] for spark in self.spark_drives]
        angular_velocities = [self.spark_dict[spark]['velocity'] for spark in self.spark_turns]
        speeds = four_motor_swerve_drivetrain(*velocities, *angular_velocities, x_wheelbase=2, y_wheelbase=2,
        speed=5, deadzone=None,)

        self.physics_controller.drive(speeds, tm_diff)
        pose = self.physics_controller.get_pose()
        self.x, self.y, self.theta  = pose.X(), pose.Y(), pose.rotation().degrees()
        wpilib.SmartDashboard.putNumberArray('sim_pose', [self.x, self.y, self.theta])
        wpilib.SmartDashboard.putNumberArray('drive_pose', [self.x, self.y, self.theta])  # need this for 2429 python dashboard to update

        # optional: compute encoder
        # l_encoder = self.drivetrain.wheelSpeeds.left * tm_diff

        # Update the navx gyro simulation
        # -> FRC gyros like NavX are positive clockwise, but the returned pose is positive counter-clockwise
        self.navx_yaw.set((self.theta % 360))  # although we should be able to get this from a drivesim
